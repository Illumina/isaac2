/**
 ** Isaac Genome Alignment Software
 ** Copyright (c) 2010-2014 Illumina, Inc.
 ** All rights reserved.
 **
 ** This software is provided under the terms and conditions of the
 ** GNU GENERAL PUBLIC LICENSE Version 3
 **
 ** You should have received a copy of the GNU GENERAL PUBLIC LICENSE Version 3
 ** along with this program. If not, see
 ** <https://github.com/illumina/licenses/>.
 **
 ** \file BgzfCompressor.hh
 **
 ** \brief implements bgzf filtering stream by buffering the compressed data and
 ** rewriting gzip header generated by boost::iostreams::gzip_compressor.
 **
 ** \author Roman Petrovski
 **/

#ifndef iSAAC_BGZF_BGZF_COMPRESSOR_HH
#define iSAAC_BGZF_BGZF_COMPRESSOR_HH

#include <boost/iostreams/filtering_stream.hpp>
#include <boost/iostreams/filter/gzip.hpp>

#include "bgzf/Bgzf.hh"

namespace isaac
{
namespace bgzf
{

namespace bios=boost::iostreams;

class BgzfCompressor
{
public:
    typedef char char_type;
    struct category : bios::multichar_output_filter_tag , bios::flushable_tag {};
public:
    BgzfCompressor(const bios::gzip_params& = bios::gzip::default_compression);
    BgzfCompressor(const BgzfCompressor& that);

    template <typename Sink>
    std::streamsize write(Sink &snk, const char* s, std::streamsize n);

    void close();

    template<typename Sink>
    bool flush(Sink& snk);

private:
    void initBuffer();
    void rewriteHeader();

    BAM_XFIELD makeBamXfield()
    {
        unsigned short bsize(bgzf_buffer.size()-1);
        BAM_XFIELD ret =
        {
         {(sizeof(BAM_XFIELD) - sizeof(short)), (sizeof(BAM_XFIELD) - sizeof(short)) / 256},
         66, 67, {2,0}, {(unsigned char)(bsize), (unsigned char)(bsize / 256)}
        };
        return ret;
    }
    // unverified number of bytes the compressor would add to data with compression level 0
    static const size_t gzip_junk = 41;
    // bgzf cannot handle blocks over 0xFFFF bytes long. assume 1/1 compression ratio for input data
    static const unsigned bgzf_buffer_size_ = 0xFFFF;
    static const unsigned short max_uncompressed_per_block_ = bgzf_buffer_size_ - gzip_junk;
    const bios::gzip_params gzip_params_;

    std::vector<char> bgzf_buffer;
    boost::iostreams::gzip_compressor compressor_;

    // as it is difficult to predict the size of compressed data, the buffering is based on
    // the amount of uncompressed data consumed. The assumption is that compressed data
    // will always require no more space than the uncompressed.
    size_t uncompressed_in_;
};

void BgzfCompressor::rewriteHeader()
{
    memmove(&bgzf_buffer[0], &bgzf_buffer[sizeof(BAM_XFIELD)], sizeof(Header) - sizeof(BAM_XFIELD));
    Header *h(reinterpret_cast<Header*>(&bgzf_buffer[0]));
    h->xfield = makeBamXfield();
    h->FLG |= 0x04; // tell gzip that XLEN is in effect now.
}

void BgzfCompressor::initBuffer()
{
    bgzf_buffer.clear();
    uncompressed_in_ = 0;
    bgzf_buffer.insert(bgzf_buffer.begin(), sizeof(BAM_XFIELD), 0); //make some room for xfield

//    ISAAC_THREAD_CERR << "buffer init size: " << bgzf_buffer.size() << "\n";

}

BgzfCompressor::BgzfCompressor(const bios::gzip_params& gzip_params):
    gzip_params_(gzip_params),
    compressor_(gzip_params_),
    uncompressed_in_(0)
{
    bgzf_buffer.reserve(bgzf_buffer_size_); //single chunk cannot hold more than 65535 compressed bytes
    initBuffer();
}

BgzfCompressor::BgzfCompressor(const BgzfCompressor& that):
    gzip_params_(that.gzip_params_),
    compressor_(gzip_params_),
    uncompressed_in_(0)
{
    bgzf_buffer.reserve(bgzf_buffer_size_); //single chunk cannot hold more than 65535 compressed bytes
    initBuffer();
}

template <typename Sink>
std::streamsize BgzfCompressor::write(Sink &snk, const char* s, std::streamsize src_size)
{
    const size_t buffer_left(max_uncompressed_per_block_ - uncompressed_in_);
    const std::streamsize to_buffer(std::min<std::streamsize>(buffer_left, src_size));

//    ISAAC_THREAD_CERR << "will buffer: " << to_buffer << " out of " << src_size << " bytes\n";

    if (to_buffer)
    {
        bios::back_insert_device<std::vector<char> > compressorSnk(bgzf_buffer);
        const std::streamsize written = compressor_.write(compressorSnk, s, to_buffer);
        if (written != to_buffer)
        {
            return written;
        }
        uncompressed_in_ += to_buffer;
    }

    if (src_size != to_buffer)
    {
        if (!flush(snk))
        {
            return to_buffer;
        }
        const std::streamsize more = src_size - to_buffer;
        const std::streamsize written = write(snk, s + to_buffer, more);
        if (more != written)
        {
            return to_buffer + written;
        }
    }

    return src_size;
}

void BgzfCompressor::close()
{
}

template<typename Sink>
bool BgzfCompressor::flush(Sink& snk)
{
    if (uncompressed_in_)
    {
        bios::back_insert_device<std::vector<char> > compressorSnk(bgzf_buffer);
        compressor_.close(compressorSnk, BOOST_IOS::out);
//        ISAAC_THREAD_CERR << "triggering gzip flush at " << bgzf_buffer.size() << " bytes\n";

        rewriteHeader();
        if (std::streamsize(bgzf_buffer.size()) != bios::write(snk, &bgzf_buffer.front(), bgzf_buffer.size()))
        {
            return false;
        }

        initBuffer();
    }
    return true;
}



} // namespace bgzf
} // namespace isaac


#endif // iSAAC_BGZF_BGZF_COMPRESSOR_HH
